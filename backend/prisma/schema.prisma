generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/* =========================
   MODELOS DE USUARIO/ROLES
   ========================= */

model Usuario {
  id            Int      @id @default(autoincrement())
  nombre        String
  usuario       String   @unique
  correo        String   @unique
  contrasena    String
  estado        Boolean  @default(true)
  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt

  rolId Int
  rol   Rol @relation(fields: [rolId], references: [id])

  historialModificaciones HistorialModificacion[] @relation("ModificacionesDelUsuario")
  historialResponsable    HistorialModificacion[] @relation("ModificacionesHechasPor")

  // Órdenes donde este usuario actúa como mesero
  ordenesMesero Orden[] @relation("OrdenesDelMesero")

  // Ítems asignados como chef
  itemsAsignados OrdenItem[] @relation("AsignadoAlChef")

  // Estado de actividad en cocina (1:1 opcional)
  cocinaEstado CocinaChef?
}

model Rol {
  id       Int       @id @default(autoincrement())
  nombre   String    @unique
  usuarios Usuario[]
  permisos PermisoPorRol[]
}

model Permiso {
  id          Int                @id @default(autoincrement())
  nombre      String             @unique
  descripcion String?
  roles       PermisoPorRol[]
}

model PermisoPorRol {
  id         Int      @id @default(autoincrement())
  permisoId  Int
  rolId      Int
  permiso    Permiso  @relation(fields: [permisoId], references: [id])
  rol        Rol      @relation(fields: [rolId], references: [id])

  @@unique([permisoId, rolId])
}

/* =========================
   CATALOGO: CATEGORÍAS/PLATILLOS
   ========================= */

model Categoria {
  id        Int        @id @default(autoincrement())
  nombre    String     @unique
  activo    Boolean    @default(true)
  creadoEn  DateTime   @default(now())
  platillos Platillo[]
}

model Platillo {
  id         Int      @id @default(autoincrement())
  nombre     String   @unique
  precio     Float
  creadoEn   DateTime @default(now())
  disponible Boolean  @default(true)
  imagenUrl  String?

  categoriaId Int
  categoria   Categoria @relation(fields: [categoriaId], references: [id])

  historialModificaciones HistorialModificacion[]
}

/* =========================
   HISTORIAL
   ========================= */

model HistorialModificacion {
  id            Int      @id @default(autoincrement())
  campo         String
  valorAnterior String?
  valorNuevo    String?
  fecha         DateTime @default(now())
  accion        String

  responsableId Int
  responsable   Usuario @relation("ModificacionesHechasPor", fields: [responsableId], references: [id])

  usuarioId Int?
  usuario   Usuario? @relation("ModificacionesDelUsuario", fields: [usuarioId], references: [id])

  platilloId Int?
  platillo   Platillo? @relation(fields: [platilloId], references: [id])
}

/* =========================
   ORDEN / DETALLE
   ========================= */

model Orden {
  id Int @id @default(autoincrement())

  // Código alfanumérico de 5 caracteres generado por la BD (ej: A1F3B)
  codigo String @unique @default(dbgenerated("upper(substr(md5(random()::text),1,5))")) @db.VarChar(5)

  mesa       Int
  fecha      DateTime @default(now())  // creación de la orden
  finishedAt DateTime?                 // CUÁNDO terminó toda la orden
  durationSec Int?                     // DURACIÓN total en segundos (finishedAt - fecha)

  meseroId Int
  mesero   Usuario @relation("OrdenesDelMesero", fields: [meseroId], references: [id])

  items  OrdenItem[]
  estado String   @default("En espera")

  @@index([fecha])
  @@index([finishedAt])
}

model OrdenItem {
  id           Int       @id @default(autoincrement())
  nombre       String
  precio       Float
  nota         String?

  // Mantener como String para no romper datos; valores esperados:
  // tipo: "PLATILLO" | "BEBIDA"
  // estado: "PENDIENTE" | "ASIGNADO" | "PREPARANDO" | "LISTO"
  tipo         String
  estado       String

  creadoEn     DateTime @default(now())
  asignadoEn   DateTime?
  finalizadoEn DateTime?
  prioridad    Int?

  ordenId Int
  orden   Orden @relation(fields: [ordenId], references: [id])

  chefId Int?
  chef   Usuario? @relation("AsignadoAlChef", fields: [chefId], references: [id])

  @@index([chefId, estado])
  @@index([ordenId, tipo, estado])
}

/* (Opcional) si deseas migrar a enums nativos más adelante:
enum OrdenItemTipo {
  PLATILLO
  BEBIDA
}
enum OrdenItemEstado {
  PENDIENTE
  ASIGNADO
  PREPARANDO
  LISTO
}
*/

/* =========================
   COCINA (estado de chefs)
   ========================= */

model CocinaChef {
  id       Int      @id @default(autoincrement())
  chefId   Int      @unique
  chef     Usuario  @relation(fields: [chefId], references: [id])
  activo   Boolean  @default(true)
  lastSeen DateTime @default(now())
}
